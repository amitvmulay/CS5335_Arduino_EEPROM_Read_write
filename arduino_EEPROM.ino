/* 
 * Author: Pablo,Amit
 * Team: Pablo, Kelly, Charles, Amit
 */

# include <EEPROM.h>
#include <math.h>


/*
 * Func: eeprom_clear()
 * Clear EEPROM memory
 */
void eeprom_clear()
{
  for (int i = 0 ; i < EEPROM.length() ; i++) {
    EEPROM.write(i, 0);
  }
}

/*
 * Func: eeprom_crc()
 * CRC algorithm generated by pycrc, MIT licence ( https://github.com/tpircher/pycrc ).  
 * A CRC is a simple way of checking whether data has changed or become corrupted.
 * This example calculates a CRC value directly on the EEPROM values.
 */
unsigned long eeprom_crc(void) {

  const unsigned long crc_table[16] = {

    0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac,

    0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,

    0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c,

    0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c

  };

  unsigned long crc = ~0L;

  for (int index = 0 ; index < EEPROM.length()  ; ++index) {

    crc = crc_table[(crc ^ EEPROM[index]) & 0x0f] ^ (crc >> 4);

    crc = crc_table[(crc ^ (EEPROM[index] >> 4)) & 0x0f] ^ (crc >> 4);

    crc = ~crc;

  }

  return crc;
}


const bool READ_EEPROM = true;
const int NUM_STATES = 36;  // number of state (distance) intervals used in qtable
const int NUM_ACTIONS = 20;  // number of action (vl - vr) intervals used in qtable

int TICK = 0;

float qtable[NUM_STATES][NUM_ACTIONS] = {};



// initializes the q-table
void init_qtable() {
  for (int i = 0; i != NUM_STATES; i++) {
    for (int j = 0; j != NUM_ACTIONS; j++)
      qtable[i][j] = 0.0;
  }
}


void write_EEPROM() {
  for (int i = 0; i < NUM_STATES; i++) {
    for (int j = 0; j < NUM_ACTIONS; j++) {
      EEPROM.update(i * NUM_ACTIONS + j, qtable[j][i]);
    }
  }
}


void read_EEPROM() {
  for (int i = 0; i < NUM_STATES; i++) {
    for (int j = 0; j < NUM_ACTIONS; j++) {
      qtable[i][j] = EEPROM.read(i * NUM_ACTIONS + j);
    }
  }

  return qtable;
}


// update the qtable with new information
void update_qtable() {

  for (int i = 0; i < NUM_STATES; i++) {
    for (int j = 0; j < NUM_ACTIONS; j++) {
      if (random(10) > 5)
        qtable[i][j] += random(3);
    }
  }
}


void print_qtable() {
  for (int i = 0; i < NUM_STATES; i++) {
    for (int j = 0; j < NUM_ACTIONS; j++) {
      Serial.print((int)qtable[i][j]);
      Serial.print('|');
    }
    Serial.println();
  }
  Serial.println();
}

void setup() {
  randomSeed(analogRead(0)); // used for mock update
  
  //Check if EEPROM is changed or currupted using eeprom_crc() function.
  //Print length of data to run CRC on.

  Serial.print("EEPROM length: ");

  Serial.println(EEPROM.length());

  //Print the result of calling eeprom_crc()

  Serial.print("CRC32 of EEPROM data: 0x");

  Serial.println(eeprom_crc(), HEX);

  Serial.print("\n\nDone!");

  Serial.begin(9600);
  if (READ_EEPROM) {
    read_EEPROM();
  } else {
    init_qtable();
  }

  print_qtable();
  eeprom_clear();
}

void loop() {
  update_qtable();

  if (TICK % 100 == 0) {
    print_qtable();
    Serial.println("WRITING...");
    write_EEPROM();
  }
  Serial.println(TICK);
  TICK++;
}
